// Attributes
attribute vec4 a_position;									// Vertex Position							(x, y, z, w)
attribute vec2 a_texCoord0;									// Vertex Texture Coordinate				(u, v)
#if defined(TEXCOORD1)
attribute vec2 a_texCoord1;                                 // Second tex coord for multi-texturing
#endif
#if defined(SKINNING)
attribute vec4 a_blendWeights;								// Vertex blend weight, up to 4				(0, 1, 2, 3) 
attribute vec4 a_blendIndices;								// Vertex blend index int u_matrixPalette	(0, 1, 2, 3)
#endif

// Uniforms
uniform mat4 u_worldViewProjectionMatrix;					// Matrix4x4 to transform a position to clip space
#if defined(SKINNING)
//uniform vec4 u_matrixPalette[SKINNING_JOINT_COUNT * 3];		// Array of 4x3 matrices
uniform mat4 u_matrixPalette[SKINNING_JOINT_COUNT];
#endif
#if defined(TEXTURE_REPEAT)
uniform vec2 u_textureRepeat;								// Texture repeat for tiling
#endif
#if defined(TEXTURE_OFFSET)
uniform vec2 u_textureOffset;								// Texture offset
#endif

// Varyings
varying vec2 v_texCoord0;									// Texture Coordinate
#if defined(TEXCOORD1)
varying vec2 v_texCoord1;                                   // Second tex coord for multi-texturing
#endif

// Skinning 
#if defined(SKINNING)
vec4 _skinnedPosition;
#if defined(LIGHTING)
vec3 _skinnedNormal;
#endif


vec4 getPosition()
{
	_skinnedPosition = vec4(0.0);
 
    //vec3 posOS = vec3(0.0,0.0,0.0);
	ivec4 iboneInd = ivec4(a_blendIndices);
   
	posOS += u_matrixPalette[iboneInd.x] * a_position * a_blendWeights.x;
	posOS += u_matrixPalette[iboneInd.y] * a_position * a_blendWeights.y;
	posOS += u_matrixPalette[iboneInd.z] * a_position * a_blendWeights.z;
	posOS += u_matrixPalette[iboneInd.w] * a_position * a_blendWeights.w;
	
	//_skinnedPosition = vec4(posOS,1.0);  

    return _skinnedPosition;    
}

#if defined(LIGHTING)

vec3 getTangentSpaceVector(vec3 vector)
{
	vector = vec3(0.0);
	
    ivec4 iboneInd = ivec4(a_blendIndices);
   
	vector += u_matrixPalette[iboneInd.x] * vector * a_blendWeights.x;
	vector += u_matrixPalette[iboneInd.y] * vector * a_blendWeights.y;
	vector += u_matrixPalette[iboneInd.z] * vector * a_blendWeights.z;
	vector += u_matrixPalette[iboneInd.w] * vector * a_blendWeights.w;
	
	retutn vector;
}

vec3 getNormal()
{
    return getTangentSpaceVector(a_normal);
}

#if defined(BUMPED)

vec3 getTangent()
{
    return getTangentSpaceVector(a_tangent);
}

vec3 getBinormal()
{
    return getTangentSpaceVector(a_binormal);
}

#endif
#endif
#else
vec4 getPosition()
{
    return a_position;    
}

#if defined(LIGHTING)

vec3 getNormal()
{
    return a_normal;
}

#if defined(BUMPED)

vec3 getTangent()
{
    return a_tangent;
}

vec3 getBinormal()
{
    return a_binormal;
}

#endif

#endif 
#endif


void main()
{
    // Get the vertex position
    vec4 position = getPosition();

    // Transform position to clip space.
    gl_Position = u_worldViewProjectionMatrix * position;

    // Texture transformation.
    v_texCoord0 = a_texCoord0;
    #if defined(TEXCOORD1)
    v_texCoord1 = a_texCoord1;
    #endif
    #if defined(TEXTURE_REPEAT)
    v_texCoord0 *= u_textureRepeat;
    #endif
    #if defined(TEXTURE_OFFSET)
    v_texCoord0 += u_textureOffset;
    #endif
}

